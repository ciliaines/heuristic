[1mdiff --git a/Heuristic_Visualizer.py b/Heuristic_Visualizer.py[m
[1mindex e18bbb8..340a583 100644[m
[1m--- a/Heuristic_Visualizer.py[m
[1m+++ b/Heuristic_Visualizer.py[m
[36m@@ -125,31 +125,19 @@[m [mdef Evaluation_function(Number_of_edges, Connection_probability,Number_of_Stream[m
             #utilizacion = False[m
             num_stream = num_stream + 1[m
 [m
[31m-        final_time = time.time()[m
[32m+[m[32m        final_time = time.time()        ### This will store the results into a txt for further usage[m
[32m+[m[32m        time_evaluation = final_time - initial_time[m
[32m+[m[41m        [m
         ################################################################[m
         Feasibility_indicator, Result_offsets, Clean_offsets_collector, Results_latencies = Heuristic_results_visualizer(instance, Model_Descriptor_vector)[m
[31m-        #PLOT[m
[31m-        network_fig = network_topology(Sources,Destinations)[m
[31m-        gantt_fig = gantt_chart(Result_offsets, Repetitions, Streams_Period)[m
[31m-        info_fig = info_box(Network_links, Repetitions, Streams_Period, Link_order_Descriptor, Streams_links_paths)[m
[31m-        combined(network_fig,gantt_fig,info_fig, file_image)[m
[31m-        [m
[31m-        #network_topology(Sources,Destinations)[m
[31m-        #gantt_chart_generator(Result_offsets, Repetitions, Streams_Period)[m
[31m-        #information_generator(Repetitions, Streams_Period, Link_order_Descriptor, Network_links, [m
[31m-        #Streams_links_paths, input_name)[m
[31m-[m
[31m-        #dataframe_printer(instance, Clean_offsets_collector, Results_latencies, Feasibility_indicator, Adjacency_Matrix, Stream_Source_Destination, Link_order_Descriptor, Links_per_Stream, Frames_per_Stream, Deathline_Stream, Streams_Period, Streams_size)[m
[31m-        #Escribir la topologia escogida en un json para ejecutarla ams tarde, se podria en la rama diario[m
[31m-        Write(input, input_timestamp, Number_of_Streams, Streams_Period, Deathline_Stream, Streams_size, Stream_Source_Destination)        [m
[31m-[m
[32m+[m[32m        set_offset=""[m
[32m+[m[32m        lower_latency=""[m
[32m+[m[32m        queues_link=""[m
[32m+[m[32m        queues_stream=""[m
         #guardar varibale del tiempo en un archovp[m
         with open ('variable.txt', 'w') as file:[m
             file.write(timestamp)[m
         [m
[31m-[m
[31m-        ### This will store the results into a txt for further usage[m
[31m-        time_evaluation = final_time - initial_time[m
         with open('Results/' + input_name + '.txt', 'a') as f :[m
             f.write("\n")[m
             f.write("Execution time:    ")[m
[36m@@ -159,17 +147,26 @@[m [mdef Evaluation_function(Number_of_edges, Connection_probability,Number_of_Stream[m
                 for j in instance.Links:[m
                     for k in instance.Frames:[m
                         if Model_Descriptor_vector [i][k][j] :[m
[31m-                            f.write("The offset of stream " + str(i) + " link " +str(j)+ " frame " + str(k) + " is " + str(instance.Lower_bound[i,j,k].value) + "\n")[m
[32m+[m[32m                           f.write("The offset of stream " + str(i) + " link " +str(j)+ " frame " + str(k) + " is " + str(instance.Lower_bound[i,j,k].value) + "\n")[m
[32m+[m[32m                           set_offset+="The offset of stream " + str(i) + " link " +str(j)+ " frame " + str(k) + " is " + str(instance.Lower_bound[i,j,k].value) + "\n"[m
             f.write("############### This is the set of latencies ######################" + "\n")[m
             for stream in instance.Streams:[m
                 f.write("The lower latency of Stream " + str(stream) + " is " + str(instance.Latency[stream].value) + "\n")[m
[32m+[m[32m                lower_latency +="The lower latency of Stream " + str(stream) + " is " + str(instance.Latency[stream].value) + "\n"[m
             f.write("############### This is the set of queues ######################" + "\n")[m
             for link in instance.Links:[m
                 f.write("The number of queues of link " + str(link) + " is " + str(instance.Num_Queues[link].value+1) + "\n")[m
[32m+[m[32m                queues_link +="The number of queues of link " + str(link) + " is " + str(instance.Num_Queues[link].value+1) + "\n"[m
             f.write("############### This is the set of queues per stream and link######################" + "\n")[m
             for stream in instance.Streams:[m
                 for link in instance.Links:[m
                     f.write("The number of queues of Link " + str(link) + " stream " + str(stream) + " is " + str(instance.Queue_Assignment[stream, link].value) + "\n")[m
[32m+[m[32m                    queues_stream += "The number of queues of Link " + str(link) + " stream " + str(stream) + " is " + str(instance.Queue_Assignment[stream, link].value) + "\n"[m
[32m+[m[32m        #PLOT[m
[32m+[m[32m        network_fig = network_topology(Sources,Destinations)[m
[32m+[m[32m        gantt_fig = gantt_chart(Result_offsets, Repetitions, Streams_Period)[m
[32m+[m[32m        info_fig = info_box(time_evaluation,Network_links, Repetitions, Streams_Period, Link_order_Descriptor, Streams_links_paths,set_offset,lower_latency,queues_link,queues_stream)[m
[32m+[m[32m        combined(network_fig,gantt_fig,info_fig, file_image)[m
     except ValueError:[m
         print("One error has occurred")[m
 [m
